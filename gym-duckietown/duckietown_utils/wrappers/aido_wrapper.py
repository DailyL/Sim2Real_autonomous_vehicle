"""
Gym-duckietown produces a physically accurate motion blur on the observations by rendering multiple frames while
simulating the robot's movement in very small steps. The blurred observations are generated by averaging these frames
together.
AIDOWrapper implements the same observation generation method in gym-duckietown as a gym wrapper class.
Warning: Using AIDOWrapper slows down the environment simulation (and therefore the training)!
Computing an observation can take 10-20 times longer as without it!
This module is derived from a the AIDO simulator container's /project/src/duckietown_simulator_gym/code.py module.
"""
__license__ = "MIT"
__copyright__ = "Copyright (c) 2020 AndrÃ¡s Kalapos"


import math
import random
import time
import logging
from typing import cast, Dict, Iterator, List, Optional, Tuple
import gc

import cv2
import geometry
import numpy as np
import yaml
import gym

from gym_duckietown.simulator import Simulator, DynamicsInfo

logger = logging.getLogger(__name__)


def get_snapshots(last_obs_time: float, current_time: float, until: float, dt: float) -> Iterator[float]:
    t = last_obs_time + dt
    while t < until:
        if t > current_time:
            yield t
        t += dt


def get_min_render_dt(speed: float, angular_deg: float, camera_dt: float) -> float:
    fov_deg = 60.0
    pixels_fov = 640
    pixels_deg = pixels_fov / fov_deg
    max_pixel_mov = 3
    angular_pixel_mov_sec = np.abs(angular_deg) * pixels_deg

    D = 0.3
    H = 0.1
    beta0 = np.arctan(D / H)
    beta1 = np.arctan((D + speed * 1.0 / H))
    hori_motion_apparent_motion_deg_s = beta1 - beta0
    linear_pixel_mov_sec = hori_motion_apparent_motion_deg_s * pixels_deg * 2

    current_pixel_mov_sec = linear_pixel_mov_sec + angular_pixel_mov_sec

    # fps = current_pixel_mov_sec / max_pixel_mov
    # current_pixel_mov_sec   = * dt <= max_pixel_mov
    dt_max = min(max_pixel_mov / current_pixel_mov_sec, camera_dt / 2)
    return dt_max


class AIDOWrapper(gym.Wrapper):
    def __init__(self, env: Simulator, blur_time=0.05):
        super(AIDOWrapper, self).__init__(env)
        self.blur_time = blur_time
        self.camera_dt: float = 1 / 15.0
        self.render_dt: float = 1 / (15.0 * 14)
        self.minimum_physics_dt: float = 1 / 200.0
        self.last_observations = None

        self.last_observations_time = -1000
        self.last_render_time = -1000
        self.current_time = 0.
        self.render_observations = []
        self.render_timestamps = []

    def step(self, action: np.ndarray):
        action = np.clip(action, -1, 1)
        delta_time = self.unwrapped.delta_time * self.unwrapped.frame_skip
        until = self.current_time + delta_time
        # f'stepping forward {int(delta_time * 1000)} s of simulation time'
        self.update_physics_and_observations(action=action, until=until)
        self.unwrapped.step_count += self.unwrapped.frame_skip
        self.current_time = until

        info = self.unwrapped.get_agent_info()
        d = self.unwrapped._compute_done_reward()
        info["Simulator"]["msg"] = d.done_why

        gc.collect()

        return self.obs, d.reward, d.done, info

    def reset(self, **kwargs):
        self.last_observations_time = -1000
        self.last_render_time = -1000
        self.current_time = 0.
        self.render_observations = []
        self.render_timestamps = []
        return self.env.reset(**kwargs)

    def update_physics_and_observations(self, action: np.ndarray, until: float):
        # we are at self.current_time and need to update until "until"
        physics_dt = self.minimum_physics_dt

        last_observations_time = self.last_observations_time
        snapshots = list(get_snapshots(last_observations_time, self.current_time, until, physics_dt))

        steps = snapshots + [until]
        # logger.info(f'current time: {self.current_time}')
        # logger.info(f'       until: {until}')
        # logger.info(f'    last_obs: {self.last_observations_time}')
        # logger.info(f'   snapshots: {snapshots}')

        for i, t1 in enumerate(steps):
            delta_time = t1 - self.current_time
            # update_physics uses _update_pos that doesn't respect delta_time passed to update_physics
            # instead it uses self.unwrapped.delta_time
            # -> we call integrate on the actual action later
            sim_internal_delta_time = self.unwrapped.delta_time
            self.unwrapped.delta_time = delta_time
            self.unwrapped.update_physics(action, delta_time=delta_time)
            self.unwrapped.step_count -=1
            self.unwrapped.delta_time = sim_internal_delta_time
            # self.unwrapped.state = self.unwrapped.state.integrate(delta_time, DynamicsInfo(motor_left=action[0],
            #                                                                                motor_right=action[1]))
            self.current_time = t1

            self._render()
            self.update_observations(self.current_time)

    def _render(self):
        # set the pose of this robot as the "protagonist"
        if self.render_timestamps:
            q, v = self.unwrapped.state.TSE2_from_state()
            dt = self.current_time - self.render_timestamps[-1]
            linear, angular = geometry.linear_angular_from_se2(v)
            angular_deg = np.rad2deg(angular)

            speed = linear[0]

            dt_max = get_min_render_dt(speed, angular_deg, self.camera_dt)

            do_it = dt >= dt_max
        else:
            do_it = True

        if do_it:
            obs = self.unwrapped.render_obs()
            self.render_observations.append(obs)
            self.render_timestamps.append(self.current_time)

    def update_observations(self, current_time: float):
        # context.info(f'update_observations() at {current_time}')
        assert self.render_observations

        dt = current_time - self.last_observations_time
        if dt < self.camera_dt:
            return

        to_average = []
        n = len(self.render_observations)
        # context.info(str(self.render_timestamps))
        # context.info(f'now {self.current_time}')
        for i in range(n):
            ti = self.render_timestamps[i]

            if math.fabs(current_time - ti) <= self.blur_time:
                to_average.append(self.render_observations[i])

            # need to remove the old stuff, otherwise memory grows unbounded
            if math.fabs(current_time - ti) > 5:
                self.render_observations[i] = None
        logger.debug(f"Not None render_observations: {len([x for x in self.render_observations if x is not None])}")
        if not to_average:
            msg = "Cannot find observations to average"
            raise Exception(msg)

        if len(to_average) == 1:
            obs = to_average[0]
        else:
            obs0 = to_average[0].astype("float32")

            for obs in to_average[1:]:
                obs0 += obs
            obs = obs0 / len(to_average)

        obs = obs.astype('uint8')
        self.last_observations_time = current_time
        self.obs = obs