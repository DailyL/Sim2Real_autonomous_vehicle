# Package `easy_node` {#easy_node}

<move-here src='#easy_node-autogenerated'/>

## YAML file format

For a node with the name `![my node]`, implemented in the file
`src/![my node].py` you must create a file by
 the name `![my node].easy_node.yaml`somewhere in the package.


This is the smallest example of an empty configuration:

    description: My node
    parameters: {}
    subscriptions: {}
    publishers: {}
    contracts: {}

### `parameters` section: configuring parameters

This is the syntax:

    parameters:
        ![name parameter]:
            type: ![type]
            desc: ![description]
            default: ![default value]

where:

- `![type]` is one of `float`, `int`, `bool`, `str`.
- `![description]` is a description that will appear in the documentation.
- The optional field `default` gives a default value for the parameter.

For example:

    parameters:
        k_d:
            type: float
            desc: The derivative gain.
            default: 1.02

### `publishers` and `subscriptions` section

The syntax for describing subscribers is:

    subscriptions:
        ![name subscription]:
            topic: ![topic name]
            type: ![message type]
            desc: ![description]

            queue_size: ![queue size]
            latch: ![latch]
            process: ![process]

The parameters are as follows.

`![topic name]` is the name of the topic to subscribe.

`![message type]` is a ROS message type name, such as `sensor_msgs/Joy`.

`![description]` is a Markdown description string.

`![queue size]`, `![latch]` are optional parameters for
  ROS publishing/subscribing functions.

See the [ROS documentation][queue_size].

[queue_size]: http://wiki.ros.org/rospy/Overview/Publishers%20and%20Subscribers#queue_size:_publish.28.29_behavior_and_queuing

The optional parameter `![process]`, one of `synchronous` (default) or `asynchronous` describes whether to process the message in a synchronous or asynchronous way (in a separated thread).

The optional parameter `![timeout]` describes a timeout value. If no message is received for more than this value, the function `on_timeout_![subscription]()` is called.

TODO: implement this timeout functionality.


The syntax for describing publishers is similar; it does not have the
the `process` and `timeout` value.

Example:


    subscriptions:
        segment_list:
            topic: ~segment_list
            type: duckietown_msgs/SegmentList
            desc: Line detections
            queue_size: 1
            timeout: 3

    publishers:
        lane_pose:
            topic: ~lane_pose
            type: duckietown_msgs/LanePose
            desc: Estimated pose
            queue_size: 1


### Describing contracts

Note: This is not implemented yet.

The idea is to have a place where we can describe constraints such as:

- "This topic must publish at least at 30 Hz."
- "Panic if you didn't receive a message for 2 seconds."
- "The maximum latency for this is 0.2 s"

Then, we can implement all these checks once and for all in a proper way,
instead of relying on multiple broken implementations

## Using the `easy_node` API


### Initialization

Here is a minimal example of a node that conforms with the API:

    from easy_node import EasyNode

    class MyNode(EasyNode):

        def __init__(self):
            EasyNode.__init__(self, 'my_package', 'my_node')
            self.info('Initialized.')

    if __name__ == '__main__':
        MyNode().spin()

The node class must derive from `EasyNode`.
You need to tell EasyNode what is the package name and the node name.

To initialize, call the function `spin()`.

The `EasyNode` class provides the following functions:

    info()
    debug()
    error()

These are mapped to `rospy.loginfo()` etc.; they include the name of the node.



### Using configuration parameters

This next example shows how to use configuration parameters.

First, create a file `my_node.easy_node.yaml` containing:

    parameters:
        num_cells:
            desc: Number of cells.
            type: int
            default: 42
    subscriptions: {}
    contracts: {}
    publishers: {}

Then, implement the method `on_parameters_changed()`. It takes
two parameters:

- `first_time` is a boolean that tells whether this is the first time
  that the function is called (initialization time).
- `updated` is a set of strings that describe the set of parameters
  that changed. The first time, it contains the set of all parameters.

To access the parameter value, access `self.config.![parameter]`.

Example:

    class MyNode():

        def __init__(self):
            EasyNode.__init__(self, 'my_package', 'my_node')

    def on_parameters_changed(self, first_time, updated):
        if first_time:
            self.info('Initializing array for the first time.')
            self.cells = [0] * self.config.num_cells

        else:
            if 'num_cells' in updated:
                self.info('Number of cells changed.')
                self.cells = [0] * self.config.num_cells

    if __name__ == '__main__':
        Node().spin()

EasyNode will monitor the ROS parameter server, and will call the function
`on_parameters_changed` if the user changes any parameters.


### Using subscriptions

To automatically subscribe to topics, add an entry in the `subscriptions`
section of the YAML file.

For example:

    subscriptions:
        joy:
            desc: |
                The `Joy.msg` from `joy_node` of the `joy` package.
                The vertical axis of the left stick maps to speed.
                The horizontal axis of the right stick maps to steering.
            type: sensor_msgs/Joy
            topic: ~joy
            timeout: 3.0

Then, implement the function `on_received_![name]`.

This function will be passed 2 arguments:

- a `context` object; this can be used for benchmarking ([](#easy_node-benchmarking)).
- the message object.

Example:

    class MyNode():
        # ...

        def on_received_joy(self, context, msg):
            # This is called any time a message arrives
            self.info('Message received: %s' % msg)

### Time-out

TODO: to implement

The function `on_timeout_![subscription]()` is called when
there hasn't been a message for the specified timeout interval.

    class MyNode():
        # ...

        def on_timeout_joy(self, context, time_since):
            # This is called when we have not seen a message for a while
            self.error('No joystick received since %s s.' % time_since)


### Publishers

The publisher object can be accessed at `self.publishers.![name]`.
EasyNode has taken care of all the initialization for you.

For example, suppose we specify a publisher `command` using:

    publishers:
        command:
            desc: The control command.
            type: duckietown_msgs/Twist2DStamped
            topic: ~car_cmd

Then we can use it as follows.

    class MyNode():
        # ...

        def on_received_joy(self, context, msg):
            out = Twist2DStamped()
            out.header.stamp = 0
            out.v = 0
            out.omega = 0

            self.publishers.command.publish(out)

### `on_init()` and `on_shutdown()`

Define the two methods `on_init()` and `on_shutdown()` to c

    class MyNode(EasyNode):
        # ...
       def on_init(self):
            self.info('Step 1 - Initialized')

       def on_parameters_changed(self, first_time, changed):
            self.info('Step 2 - Parameters received')

       def on_shutdown(self):
            self.info('Step 3 - Preparing for shutdown.')

Note that `on_init()` is called before `on_parameters_changed()`.

## Configuration using `easy_node`: the user's point of view

So far, we have seen how to use parameters from the node, but we
did not talk about how to specify the parameters from the user's point of view.

EasyNode introduces lots of flexibility compared to the legacy system.

### Configuration file location

The user configuration is specified using files by the pattern

    ![package_name]-![node_name].![config name].config.yaml

where `![config name]` is a short string (e.g., `baseline`).

The files can be anywhere in:

- The directory <code>&#36;{DUCKIETOWN_ROOT}/catkin_ws/src</code>;

- The directory <code>&#36;{DUCKIEFLEET_ROOT}</code>.


Several config files can exist at the same time.
For example, we could have somewhere:

    line_detector-line_detector.baseline.config.yaml
    line_detector-line_detector.fall2017.config.yaml
    line_detector-line_detector.andrea.config.yaml

where the `baseline` versions are the baseline parameters,
`fall2017` are the parameters we are using for Fall 2017,
and `andrea` are temporary parameters that the user is using.

However, there cannot be two configurations with the same filename
e.g. two copies of `line_detector-line_detector.baseline.config.yaml`.
In this case, EasyNode will raise an error.

TODO: implement this functionality.

### Configuration file format

The format of the `*.config.yaml` file is as follows:

    description: |
        ![description of what this configuration accomplishes]
    extends: [![config name], ![config name]]
    values:
        ![parameter name]: ![value]
        ![parameter  name]: ![value]

The `extends` field (optional) is a list of string. It allows to use the
specified configurations as the defaults for the current one.

For example, the file `line_detector-line_detector.baseline.config.yaml` could contain:

    description: |
        These are the standard values for the line detector.
    extends: []
    values:
        img_size: [120,160]
        top_cutoff: 40

### Configuration sequence

Which parameters are used depend on the **configuration sequence**.

The configuration sequence is a list of configuration names.

It can be specified by the environment variable `DUCKIETOWN_CONFIG_SEQUENCE`,
using a colon-separated list of strings. For example:

    $ export DUCKIETOWN_CONFIG_SEQUENCE=baseline:fall2017:andrea

The line above specifies that the configuration sequence is
`baseline`, `fall2017`, `andrea`.

The system loads the configuration in order. First, it loads the `baseline`
version. Then it loads the `fall2017` version. If a value  was already
specified in the `baseline` version, it is overwritten. If a version does not
exist, it is simply skipped.

If a parameter is not specified in any configuration, an error is raised.

Using this functionality, it is easy to have team-based customization and
user-based customization.

There are two special configuration names:

1. The configuration name "`defaults`" loads the defaults specified by the node.
   Note that the defaults are ignored otherwise.
2. The configuration name "`vehicle`" expands to the name of the vehicle being used.

TODO: the `vehicle` part is not implemented yet.

### Time-variant configuration

EasyNode allows to describe configuration that can change in time.

The use case for this is the configuration of calibration parameters:

- Calibration parameters change with time.
- We still want to access old calibration parameters, when processing logs.

The solution is to allow a date tag in the configuration name. The format for this is

    ![package_name]-![node_name].![config name].![date].config.yaml

For example, we could have the files:

    kinematics-kinematics.ferrari.20160404.config.yaml
    kinematics-kinematics.ferrari.20170101.config.yaml

Given this, EasyNode will select the configuration to use intelligently.
When reading from a bag file from 2016, the first configuration
is going to be used; for logs in 2017, the second is going to be used.

TODO: not implemented yet.

## Visualizing the configuration database

There are a few tolls used to visualize the configuration database.


### `easy_node desc`: Describing a node

The command

    $ rosrun easy_node desc ![package name] ![node name]

shows a description of the node, as specified in `![package name].![node name].easy_node.yaml`.

<div class='usage-example' markdown="1">

For example:

    $ rosrun easy_node desc line_detector2 line_detector2

shows the following:

    Configuration for node "line_detector_node2" in package "line_detector2"
    ========================================================================

     Parameters

        name                       type   default
        ----                       ----   -------
        en_update_params_interval  float  2.0
        top_cutoff                 int    (none)
        detector                   (n/a)  (none)
        img_size                   (n/a)  (none)
        verbose                    bool   True


     Subcriptions

        name       type                    topic       options         process
        ----       ----                    -----       -------         -------
        switch     BoolStamped             ~switch     queue_size = 1  synchronous
        image      CompressedImage         ~image      queue_size = 1  threaded
        transform  AntiInstagramTransform  ~transform  queue_size = 1  synchronous


     Publishers

        name              type         topic              options
        ----              ----         -----              -------
        color_segment     Image        ~colorSegment      queue_size = 1
        edge              Image        ~edge              queue_size = 1
        segment_list      SegmentList  ~segment_list      queue_size = 1
        image_with_lines  Image        ~image_with_lines  queue_size = 1


</div>

### `easy_node eval`: Evaluating a configuration sequence

The program `eval` script allows to evaluate a certain configuration sequence.

The syntax is:

    $ rosrun easy_node eval ![package name] ![node name] ![config sequence]

The tool shows also which file is responsible for the value of each parameter.

<div class='usage-example' markdown="1">

For example, the command

    $ rosrun easy_node eval line_detector2 line_detector_node2 defaults:andrea

evaluates the configuration for the `line_detector_node2` node with the configuration
sequence `defaults:andrea`.

The result is:


    Configuration result for node `line_detector_node2` (package `line_detector2`)
    The configuration sequence was ['defaults', 'baseline', 'andrea'].
    The following is the list of parameters set and their origin:
      parameter                    value                              origin
      ---------                    -----                              ------
      en_update_params_interval    2.0                                defaults
      top_cutoff                   40                                 baseline
      detector                     - line_detector.LineDetectorHSV    baseline
                                   - configuration:
                                       canny_thresholds: [80, 200]
                                       dilation_kernel_size: 3
                                       hough_max_line_gap: 1
                                       hough_min_line_length: 3
                                       hough_threshold: 2
                                       hsv_red1: [0, 140, 100]
                                       hsv_red2: [15, 255, 255]
                                       hsv_red3: [165, 140, 100]
                                       hsv_red4: [180, 255, 255]
                                       hsv_white1: [0, 0, 150]
                                       hsv_white2: [180, 60, 255]
                                       hsv_yellow1: [25, 140, 100]
                                       hsv_yellow2: [45, 255, 255]
      img_size                     [120, 160]                         baseline
      verbose                      true                               defaults


Note how we can tell which configuration file is responsible for setting each parameter.

</div>

### `easy_node summary`: Describing and validating all configuration files

The program `summary` reads all the configuration files described in the repository
and validates them against the node description.

If a configuration file refers to parameters that do not exist,
the configuration file is established to be invalid.

The syntax is:

    $ rosrun easy_node summary

<div class='usage-example' markdown="1">

For example, the output can be:

    package name      node name              config_name    effective     extends    valid    error    description
    line_detector2    line_detector_node2    baseline       2017-01-01    ()         yes               These are the standard values for t [..]

</div>

## Benchmarking {#easy_node-benchmarking}

EasyNode implements some simple timing statistics. These are accessed using
the `context` object passed to the message received callbacks.

Here's an example use, from [`line_detector2`](#line_detector2-line_detector_node2):

    def on_received_image(self, context, image_msg):

        with context.phase('decoding'):
            ...

        with context.phase('resizing'):
            # Resize and crop image
            ...

        stats = context.get_stats()
        self.info(stats)

The idea is to enclose the different phases of the computation
using the [context manager](+software_devel#python-context-manager) `phase(![name])`.

A summary of the statistics can be accessed by using `context.get_stats()`.

For example, this will print:

    Last 24.4 s: received 734 (30.0 fps) processed 301 (12.3 fps) skipped 433 (17.7 fps) (59 %)
                decoding | total latency  25.5 ms | delta wall   20.7 ms | delta clock  20.7 ms
                resizing | total latency  26.6 ms | delta wall    0.8 ms | delta clock   0.7 ms
              correcting | total latency  29.1 ms | delta wall    2.2 ms | delta clock   2.2 ms
               detection | total latency  47.7 ms | delta wall   18.2 ms | delta clock  21.3 ms
        preparing-images | total latency  55.0 ms | delta wall    7.0 ms | delta clock   7.0 ms
              publishing | total latency  55.5 ms | delta wall    0.1 ms | delta clock   0.1 ms
              draw-lines | total latency  59.7 ms | delta wall    4.0 ms | delta clock   3.9 ms
        published-images | total latency  61.2 ms | delta wall    0.9 ms | delta clock   0.8 ms
    pub_edge/pub_segment | total latency  86.3 ms | delta wall   24.7 ms | delta clock  24.0 ms



## Automatic documentation generation

EasyNode generated the documentation automatically from the `*.easy_node.yaml`
files.

Note that this can be used independently of the fact that the node
implements the `EasyNode` API. So, we can use this EasyNode functionality
also to document the legacy nodes.

To generate the docs, use this command:

    $ rosrun easy_node generate_docs

For each node documented using a `*.easy_node.yaml`, this generates a Markdown
file called  "`![node name]-easy_node-autogenerated.md`" in the package
directory.

The contents are enclosed in a `div` with ID `#![package name]-![node name]-autogenerated`.

The intended use is that this can be used to move the contents
to the place in the documentation using [the `move-here` tag](#move-here).

For example, in the `README.md` of the `joy_mapper` package, we have:

    ## Node `joy_mapper_node`

    <move-here src="#joy_mapper-joy_mapper_node-autogenerated"/>

The result can be seen at [](#joy_mapper).

## Parameters and services defined for all packages

<move-here src="#easy_node-easy_node-autogenerated"/>

## Other ideas

(Add here other ideas that we can implement.)


<style>
    .usage-example pre {
        font-size: 50%;
    }
</style>
