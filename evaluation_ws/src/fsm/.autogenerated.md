<div id='fsm-autogenerated' markdown='1'>


<!-- do not edit this file, autogenerated -->

## Package information 

[Link to package on Github](github:org=duckietown,repo=Software,path=20-indefinite-navigation/fsm,branch=master18)

### Essentials {nonumber="1"}

Author: [Michael Misha Novitzky](mailto:novitzky@mit.edu)

Maintainer: [Mack](mailto:mack@duckietown.org)

### Description {nonumber="1"}

The finite state machine coordinates the modes of the car. The fsm package consists of two nodes, namely `fsm_node` and `logic_gate_node`.
  



</div>

<!-- file start -->

<div id='fsm-logic_gate_node-autogenerated' markdown='1'>


<!-- do not edit this file, autogenerated -->

(Generated from [configuration `logic_gate_node.easy_node.yaml`](github:org=duckietown,repo=Software,path=logic_gate_node.easy_node.yaml,branch=master18).)

**logic_gate_node**


This node handles AND and OR logic gates of events for state transitions. Below is a summary of the basic functionality of the `logic_gate_node`.

* Logic AND and OR gates can be defined
* For each gate, the input events (and their corresponding topics) are defined
* The `logic_gate_node` subscribes to all of these input event topics
* When an input topic is published, the `logic_gate_node` checks whether the AND or OR gate is satisfied
* If the gate is satisfied, the node publishes `True` on the `~/gate_name` topic, else it publishes `False`  

The logic gate node publishes on many topics according to the configuration:

    for gate_name, gate_dict in self.gates_dict.items():
        output_topic_name = gate_dict["output_topic"]
        self.pub_dict[gate_name] = rospy.Publisher(output_topic_name, BoolStamped, queue_size=1)

where `gate_dict.items()` is a dictionary of all gates, and `output_topic_name` is `~/gate_name`. The `fsm_node` then subscribes to `logic_gate_node/*`, where each `gate_name` corresponds to a state transition event. 


### Parameters {nonumber="1"}

**Parameter `events`**: `dict`; default value: `{}`

These are all the events and corresponding topics (and trigger values) which are inputs to a logic gate event.

**Parameter `gates`**: `dict`; default value: `{}`

These are the logic gate events. Each gate has a gate_type (AND or OR), input events, and an output topic.

### Subscriptions {nonumber="1"}

No subscriptions defined.

### Publishers {nonumber="1"}

No publishers defined.



</div><!-- file start -->

<div id='fsm-fsm_node-autogenerated' markdown='1'>


<!-- do not edit this file, autogenerated -->

(Generated from [configuration `fsm_node.easy_node.yaml`](github:org=duckietown,repo=Software,path=fsm_node.easy_node.yaml,branch=master18).)

**fsm_node**


This node handles the state transitions based on the defined state transition events. Below is a summary of the basic functionality of the `fsm_node`.

* Each state is a mode that the Duckiebot can be in
* Each state has corresponding state transitions triggered by events
* Each event is triggered by a certain value of a certain topic message
* In each state, certain nodes are active
* Each node affected by the state machine can be switched active/inactive by a `~/switch` topic

The current state is published to the `fsm_node/mode` topic. For each state, there is a list of nodes which should be active, which are switched by means of `node_name/switch` topics.

The FSM node publishes on many topics according to the configuration:

    for node_name, topic_name in nodes.items():
        self.pub_dict[node_name] = rospy.Publisher(topic_name, BoolStamped, ...)

where `nodes.items()` is a list of all nodes affected by the FSM, and the `topic_name` is `node_name/switch`. The relevant nodes then subscribe to `~/switch`, and toggle their behaviour based on the value of the switch. Nodes can also subscribe to the `fsm_node/mode` topic if they need to change their behaviour based on the state. An example of how a node named `ExampleNode` can handle this is shown below:

    class ExampleNode(object):
        def \__init\__(self):
        ...
        self.sub_switch = rospy.Subscriber("~switch",BoolStamped, self.cbSwitch, queue_size=1)
        self.sub_fsm_mode = rospy.Subscriber("fsm_node/mode",FSMState, self.cbMode, queue_size=1)
        self.active = True
        self.mode = None

        def cbSwitch(self,switch_msg):
            self.active = switch_msg.data # True or False

        def cbMode(self,switch_msg):
            self.mode = switch_msg.state # String of current FSM state

        def someOtherFunc(self, msg):
            if not self.active:
                return
            # else normal functionality
            ...
            if self.mode == "LANE_FOLLOWING":
                ...
            if self.mode == "INTERSECTION_CONTROL":
                ...


### Parameters {nonumber="1"}

**Parameter `states`**: `dict`; default value: `{}`

States are the modes that the system can be in. Each state has corresponding events (which trigger transitions to specific states), as well as a list of active nodes in the current state.

**Parameter `nodes`**: `dict`; default value: `{}`

These are the nodes which are affected by the FSM, and also define the `~/switch` topics to switch them between active and inactive.

**Parameter `global_transitions`**: `dict`; default value: `{}`

These are the state transition events (and corresponding topic) that can be triggered from all states.

**Parameter `initial_state`**: `str`; default value: `'LANE_FOLLOWING'`

This is the initial state that the FSM will be in upon launch of the node.

**Parameter `events`**: `dict`; default value: `{}`

These are the events and the corresponding topics (and message values) which trigger them, which allow for transitions between states.

### Subscriptions {nonumber="1"}

No subscriptions defined.

### Publishers {nonumber="1"}

**Publisher `mode`**: topic `~mode` (`FSMState`)

This topic gives the current state of the FSM, and can have values from a set of strings indicating the possible state names.



</div>