// Generated by gencpp from file duckietown_msgs/SensorsStatusResponse.msg
// DO NOT EDIT!


#ifndef DUCKIETOWN_MSGS_MESSAGE_SENSORSSTATUSRESPONSE_H
#define DUCKIETOWN_MSGS_MESSAGE_SENSORSSTATUSRESPONSE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace duckietown_msgs
{
template <class ContainerAllocator>
struct SensorsStatusResponse_
{
  typedef SensorsStatusResponse_<ContainerAllocator> Type;

  SensorsStatusResponse_()
    : state_front_bumper(false)
    , state_camera(false)
    , state_imu(false)
    , state_tof_fl(false)
    , state_tof_fm(false)
    , state_tof_fr(false)
    , state_tof_sl(false)
    , state_tof_sr(false)
    , state_tof_bl(false)
    , state_tof_bm(false)
    , state_tof_br(false)
    , state_lf_outer_left(false)
    , state_lf_outer_right(false)
    , state_lf_inner_left(false)
    , state_lf_inner_right(false)
    , state_encoder_and_motor(false)  {
    }
  SensorsStatusResponse_(const ContainerAllocator& _alloc)
    : state_front_bumper(false)
    , state_camera(false)
    , state_imu(false)
    , state_tof_fl(false)
    , state_tof_fm(false)
    , state_tof_fr(false)
    , state_tof_sl(false)
    , state_tof_sr(false)
    , state_tof_bl(false)
    , state_tof_bm(false)
    , state_tof_br(false)
    , state_lf_outer_left(false)
    , state_lf_outer_right(false)
    , state_lf_inner_left(false)
    , state_lf_inner_right(false)
    , state_encoder_and_motor(false)  {
  (void)_alloc;
    }



   typedef uint8_t _state_front_bumper_type;
  _state_front_bumper_type state_front_bumper;

   typedef uint8_t _state_camera_type;
  _state_camera_type state_camera;

   typedef uint8_t _state_imu_type;
  _state_imu_type state_imu;

   typedef uint8_t _state_tof_fl_type;
  _state_tof_fl_type state_tof_fl;

   typedef uint8_t _state_tof_fm_type;
  _state_tof_fm_type state_tof_fm;

   typedef uint8_t _state_tof_fr_type;
  _state_tof_fr_type state_tof_fr;

   typedef uint8_t _state_tof_sl_type;
  _state_tof_sl_type state_tof_sl;

   typedef uint8_t _state_tof_sr_type;
  _state_tof_sr_type state_tof_sr;

   typedef uint8_t _state_tof_bl_type;
  _state_tof_bl_type state_tof_bl;

   typedef uint8_t _state_tof_bm_type;
  _state_tof_bm_type state_tof_bm;

   typedef uint8_t _state_tof_br_type;
  _state_tof_br_type state_tof_br;

   typedef uint8_t _state_lf_outer_left_type;
  _state_lf_outer_left_type state_lf_outer_left;

   typedef uint8_t _state_lf_outer_right_type;
  _state_lf_outer_right_type state_lf_outer_right;

   typedef uint8_t _state_lf_inner_left_type;
  _state_lf_inner_left_type state_lf_inner_left;

   typedef uint8_t _state_lf_inner_right_type;
  _state_lf_inner_right_type state_lf_inner_right;

   typedef uint8_t _state_encoder_and_motor_type;
  _state_encoder_and_motor_type state_encoder_and_motor;





  typedef boost::shared_ptr< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> const> ConstPtr;

}; // struct SensorsStatusResponse_

typedef ::duckietown_msgs::SensorsStatusResponse_<std::allocator<void> > SensorsStatusResponse;

typedef boost::shared_ptr< ::duckietown_msgs::SensorsStatusResponse > SensorsStatusResponsePtr;
typedef boost::shared_ptr< ::duckietown_msgs::SensorsStatusResponse const> SensorsStatusResponseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator1> & lhs, const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator2> & rhs)
{
  return lhs.state_front_bumper == rhs.state_front_bumper &&
    lhs.state_camera == rhs.state_camera &&
    lhs.state_imu == rhs.state_imu &&
    lhs.state_tof_fl == rhs.state_tof_fl &&
    lhs.state_tof_fm == rhs.state_tof_fm &&
    lhs.state_tof_fr == rhs.state_tof_fr &&
    lhs.state_tof_sl == rhs.state_tof_sl &&
    lhs.state_tof_sr == rhs.state_tof_sr &&
    lhs.state_tof_bl == rhs.state_tof_bl &&
    lhs.state_tof_bm == rhs.state_tof_bm &&
    lhs.state_tof_br == rhs.state_tof_br &&
    lhs.state_lf_outer_left == rhs.state_lf_outer_left &&
    lhs.state_lf_outer_right == rhs.state_lf_outer_right &&
    lhs.state_lf_inner_left == rhs.state_lf_inner_left &&
    lhs.state_lf_inner_right == rhs.state_lf_inner_right &&
    lhs.state_encoder_and_motor == rhs.state_encoder_and_motor;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator1> & lhs, const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace duckietown_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b3c1ff78cc992d6d1e8b220245aad6f6";
  }

  static const char* value(const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb3c1ff78cc992d6dULL;
  static const uint64_t static_value2 = 0x1e8b220245aad6f6ULL;
};

template<class ContainerAllocator>
struct DataType< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "duckietown_msgs/SensorsStatusResponse";
  }

  static const char* value(const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool state_front_bumper\n"
"bool state_camera\n"
"bool state_imu\n"
"bool state_tof_fl\n"
"bool state_tof_fm\n"
"bool state_tof_fr\n"
"bool state_tof_sl\n"
"bool state_tof_sr\n"
"bool state_tof_bl\n"
"bool state_tof_bm\n"
"bool state_tof_br\n"
"bool state_lf_outer_left\n"
"bool state_lf_outer_right\n"
"bool state_lf_inner_left\n"
"bool state_lf_inner_right\n"
"bool state_encoder_and_motor\n"
"\n"
;
  }

  static const char* value(const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.state_front_bumper);
      stream.next(m.state_camera);
      stream.next(m.state_imu);
      stream.next(m.state_tof_fl);
      stream.next(m.state_tof_fm);
      stream.next(m.state_tof_fr);
      stream.next(m.state_tof_sl);
      stream.next(m.state_tof_sr);
      stream.next(m.state_tof_bl);
      stream.next(m.state_tof_bm);
      stream.next(m.state_tof_br);
      stream.next(m.state_lf_outer_left);
      stream.next(m.state_lf_outer_right);
      stream.next(m.state_lf_inner_left);
      stream.next(m.state_lf_inner_right);
      stream.next(m.state_encoder_and_motor);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct SensorsStatusResponse_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::duckietown_msgs::SensorsStatusResponse_<ContainerAllocator>& v)
  {
    s << indent << "state_front_bumper: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_front_bumper);
    s << indent << "state_camera: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_camera);
    s << indent << "state_imu: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_imu);
    s << indent << "state_tof_fl: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_fl);
    s << indent << "state_tof_fm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_fm);
    s << indent << "state_tof_fr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_fr);
    s << indent << "state_tof_sl: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_sl);
    s << indent << "state_tof_sr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_sr);
    s << indent << "state_tof_bl: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_bl);
    s << indent << "state_tof_bm: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_bm);
    s << indent << "state_tof_br: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_tof_br);
    s << indent << "state_lf_outer_left: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_lf_outer_left);
    s << indent << "state_lf_outer_right: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_lf_outer_right);
    s << indent << "state_lf_inner_left: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_lf_inner_left);
    s << indent << "state_lf_inner_right: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_lf_inner_right);
    s << indent << "state_encoder_and_motor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.state_encoder_and_motor);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DUCKIETOWN_MSGS_MESSAGE_SENSORSSTATUSRESPONSE_H
